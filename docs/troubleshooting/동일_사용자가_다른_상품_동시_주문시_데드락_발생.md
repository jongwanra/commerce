# [Trouble Shooting] ë™ì¼ ì‚¬ìš©ìê°€ ë‹¤ë¥¸ ìƒí’ˆ ë™ì‹œ ì£¼ë¬¸ì‹œ ë°ë“œë½ ë°œìƒ

## ë¬¸ì œ ìƒí™©

- ë™ì¼í•œ ì‚¬ìš©ìê°€ ë‹¤ë¥¸ ìƒí’ˆ A, Bë¥¼ ì£¼ë¬¸ ì‹œì— ë°ë“œë½ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
- ì—ëŸ¬: Deadlock found when trying to get lock (MySQL Error: 1213)

### Test code

```java
class OrderPlaceProcessorConcurrencyIntegrationTest extends AbstractIntegrationTestSupport {
	/**
	 * ì‘ì„± ì´ìœ : ë™ì¼ ì‚¬ìš©ìì˜ ì—¬ëŸ¬ ì£¼ë¬¸ ìš”ì²­ì´ ë™ì‹œì— ë°œìƒí•  ë•Œ,
	 * ì”ì•¡ ê²€ì¦ì˜ Race conditionìœ¼ë¡œ ì¸í•œ ìŒìˆ˜ ì”ì•¡ ë°œìƒ ì—¬ë¶€ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
	 */
	@IntegrationTest
	void ë™ì¼_ì‚¬ìš©ìê°€_ì—¬ëŸ¬_ìƒí’ˆì„_ë™ì‹œì—_ì£¼ë¬¸í• _ë•Œ_ì”ì•¡ì´_ë¶€ì¡±í•˜ë©´_ì˜ˆì™¸ë¥¼_ë°œìƒì‹œí‚¨ë‹¤() throws InterruptedException {
		// given
		final int threadCount = 2;
		final BigDecimal balance = BigDecimal.valueOf(9_900);
		UserEntity user = userJpaRepository.save(UserEntity.builder()
			.email("userA@gmail.com")
			.encryptedPassword("encrypted_password")
			.status(UserStatus.ACTIVE)
			.build());

		final Long userId = user.getId();
		cashJpaRepository.save(
			CashEntity.fromDomain(Cash.restore(
				null,
				userId,
				balance
			)));

		Product productA = productJpaRepository.save(ProductEntity.builder()
			.name("ì˜¤ëšœê¸° ì§„ë¼ë©´ ë§¤ìš´ë§› 120g")
			.price(BigDecimal.valueOf(5_000))
			.stock(1)
			.build()).toDomain();

		Product productB = productJpaRepository.save(ProductEntity.builder()
			.name("ìŠ¤íƒ€ë²…ìŠ¤ ì•„ë©”ë¦¬ì¹´ë…¸")
			.price(BigDecimal.valueOf(5_000))
			.stock(1)
			.build()).toDomain();

		List<Product> products = List.of(productA, productB);

		CountDownLatch countDownLatch = new CountDownLatch(threadCount);
		ExecutorService executorService = Executors.newFixedThreadPool(threadCount);

		// when
		IntStream.range(0, threadCount)
			.forEach((index) -> executorService.execute(() -> {
				try {
					transactionTemplate.executeWithoutResult(
						status -> orderPlaceProcessor.execute(generateCommand(userId, products.get(index))));
				} catch (Exception e) {
				} finally {
					countDownLatch.countDown();
				}
			}));

		countDownLatch.await();

		// then
		CashEntity cash = cashJpaRepository.findByUserId(userId)
			.orElseThrow();

		System.out.println("cash.getBalance() = " + cash.getBalance());
		assertThat(cash.getBalance().compareTo(BigDecimal.valueOf(4_900))).isZero()
			.as("ì²˜ìŒ ì£¼ë¬¸í•œ ìƒí’ˆë§Œ ê²°ì œê°€ ê°€ëŠ¥í•´ì•¼ í•œë‹¤.");
	}

}

```

### Console

```shell
2025-10-29T12:34:17.181+09:00  WARN 55092 --- [hhplus] [pool-2-thread-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1213, SQLState: 40001
2025-10-29T12:34:17.181+09:00 ERROR 55092 --- [hhplus] [pool-2-thread-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : Deadlock found when trying to get lock; try restarting transaction
e.getMessage() = could not execute statement [Deadlock found when trying to get lock; try restarting transaction] [insert into orders (amount,confirmed_at,created_at,discount_amount,final_amount,idempotency_key,modified_at,status,user_id) values (?,?,?,?,?,?,?,?,?)]; SQL [insert into orders (amount,confirmed_at,created_at,discount_amount,final_amount,idempotency_key,modified_at,status,user_id) values (?,?,?,?,?,?,?,?,?)]
org.springframework.dao.CannotAcquireLockException: could not execute statement [Deadlock found when trying to get lock; try restarting transaction] [insert into orders (amount,confirmed_at,created_at,discount_amount,final_amount,idempotency_key,modified_at,status,user_id) values (?,?,?,?,?,?,?,?,?)]; SQL [insert into orders (amount,confirmed_at,created_at,discount_amount,final_amount,idempotency_key,modified_at,status,user_id) values (?,?,?,?,?,?,?,?,?)]
	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:283)
	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:244)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:560)
	at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61)
	at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:343)
	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:160)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:165)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:223)
	at jdk.proxy1/jdk.proxy1.$Proxy204.save(Unknown Source)
	at kr.hhplus.be.commerce.infrastructure.persistence.order.OrderRepositoryImpl.save(OrderRepositoryImpl.java:19)
	at kr.hhplus.be.commerce.application.order.OrderPlaceProcessor.execute(OrderPlaceProcessor.java:78)
	at kr.hhplus.be.commerce.application.order.OrderPlaceProcessorConcurrencyIntegrationTest.lambda$ë™ì¼_ì‚¬ìš©ìê°€_ì—¬ëŸ¬_ìƒí’ˆì„_ë™ì‹œì—_ì£¼ë¬¸í• _ë•Œ_ì”ì•¡ì´_ë¶€ì¡±í•˜ë©´_ì˜ˆì™¸ë¥¼_ë°œìƒì‹œí‚¨ë‹¤$0(OrderPlaceProcessorConcurrencyIntegrationTest.java:123)
	at org.springframework.transaction.support.TransactionOperations.lambda$executeWithoutResult$0(TransactionOperations.java:68)
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140)
	at org.springframework.transaction.support.TransactionOperations.executeWithoutResult(TransactionOperations.java:67)
	at kr.hhplus.be.commerce.application.order.OrderPlaceProcessorConcurrencyIntegrationTest.lambda$ë™ì¼_ì‚¬ìš©ìê°€_ì—¬ëŸ¬_ìƒí’ˆì„_ë™ì‹œì—_ì£¼ë¬¸í• _ë•Œ_ì”ì•¡ì´_ë¶€ì¡±í•˜ë©´_ì˜ˆì™¸ë¥¼_ë°œìƒì‹œí‚¨ë‹¤$1(OrderPlaceProcessorConcurrencyIntegrationTest.java:122)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: org.hibernate.exception.LockAcquisitionException: could not execute statement [Deadlock found when trying to get lock; try restarting transaction] [insert into orders (amount,confirmed_at,created_at,discount_amount,final_amount,idempotency_key,modified_at,status,user_id) values (?,?,?,?,?,?,?,?,?)]
	at org.hibernate.dialect.MySQLDialect.lambda$buildSQLExceptionConversionDelegate$3(MySQLDialect.java:1260)
	at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:58)
	at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:108)
	at org.hibernate.engine.jdbc.internal.ResultSetReturnImpl.executeUpdate(ResultSetReturnImpl.java:197)
	at org.hibernate.id.insert.GetGeneratedKeysDelegate.performMutation(GetGeneratedKeysDelegate.java:116)
	at org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleNonBatched.performNonBatchedOperations(MutationExecutorSingleNonBatched.java:47)
	at org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor.execute(AbstractMutationExecutor.java:55)
	at org.hibernate.persister.entity.mutation.InsertCoordinatorStandard.doStaticInserts(InsertCoordinatorStandard.java:194)
	at org.hibernate.persister.entity.mutation.InsertCoordinatorStandard.coordinateInsert(InsertCoordinatorStandard.java:132)
	at org.hibernate.persister.entity.mutation.InsertCoordinatorStandard.insert(InsertCoordinatorStandard.java:95)
	at org.hibernate.action.internal.EntityIdentityInsertAction.execute(EntityIdentityInsertAction.java:85)
	at org.hibernate.engine.spi.ActionQueue.execute(ActionQueue.java:682)
	at org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:293)
	at org.hibernate.engine.spi.ActionQueue.addInsertAction(ActionQueue.java:274)
	at org.hibernate.engine.spi.ActionQueue.addAction(ActionQueue.java:324)
	at org.hibernate.event.internal.AbstractSaveEventListener.addInsertAction(AbstractSaveEventListener.java:393)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:307)
	at org.hibernate.event.internal.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:223)
	at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:136)
	at org.hibernate.event.internal.DefaultPersistEventListener.entityIsTransient(DefaultPersistEventListener.java:177)
	at org.hibernate.event.internal.DefaultPersistEventListener.persist(DefaultPersistEventListener.java:95)
	at org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:79)
	at org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:55)
	at org.hibernate.event.service.internal.EventListenerGroupImpl.fireEventOnEachListener(EventListenerGroupImpl.java:127)
	at org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:761)
	at org.hibernate.internal.SessionImpl.persist(SessionImpl.java:745)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:320)
	at jdk.proxy1/jdk.proxy1.$Proxy188.persist(Unknown Source)
	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:627)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359)
	at org.springframework.data.repository.core.support.RepositoryMethodInvoker$RepositoryFragmentMethodInvoker.lambda$new$0(RepositoryMethodInvoker.java:277)
	at org.springframework.data.repository.core.support.RepositoryMethodInvoker.doInvoke(RepositoryMethodInvoker.java:170)
	at org.springframework.data.repository.core.support.RepositoryMethodInvoker.invoke(RepositoryMethodInvoker.java:158)
	at org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments.invoke(RepositoryComposition.java:515)
	at org.springframework.data.repository.core.support.RepositoryComposition.invoke(RepositoryComposition.java:284)
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$ImplementationMethodExecutionInterceptor.invoke(RepositoryFactorySupport.java:752)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.doInvoke(QueryExecutorMethodInterceptor.java:174)
	at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.invoke(QueryExecutorMethodInterceptor.java:149)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:69)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:380)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138)
	... 15 more
Caused by: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:115)
	at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:114)
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:988)
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:1166)
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:1101)
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeLargeUpdate(ClientPreparedStatement.java:1467)
	at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdate(ClientPreparedStatement.java:1084)
	at com.zaxxer.hikari.pool.ProxyPreparedStatement.executeUpdate(ProxyPreparedStatement.java:61)
```

## ì›ì¸ ë¶„ì„

`orders` í…Œì´ë¸”ì—ëŠ” unique index ì œì•½ ì¡°ê±´ì´ `idempotency_key`ì— ê±¸ë ¤ìˆìŠµë‹ˆë‹¤.
ì¤‘ë³µ ì£¼ë¬¸ ë°©ì§€ë¥¼ ìœ„í•œ ì‚¬ì „ ì„ ì  ê²€ì‚¬ë¡œ `SELECT ... WHERE idempotency_key = :idempotency_key FOR UPDATE`ë¥¼ ìˆ˜í–‰í•  ë•Œ, ë ˆì½”ë“œê°€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ InnoDBê°€ í•´ë‹¹
ìœ ë‹ˆí¬ í‚¤ê°€ ì‚½ì…ë  ìœ„ì¹˜ì— ê°­ ë½ì„ ì ìœ í•©ë‹ˆë‹¤. (ì•„ë¬´ëŸ° ë ˆì½”ë“œê°€ ì—†ëŠ” `orders` í…Œì´ë¸”ì˜ ê²½ìš° unique index ì „ì²´ì— ì ê¸ˆì´ ê±¸ë¦½ë‹ˆë‹¤.)

ë™ì‹œì— ì—¬ëŸ¬ íŠ¸ëœì­ì…˜(T1, T2)ì´ ì„œë¡œ ë‹¤ë¥¸ idempotency_keyë¡œ ê°­ ë½ì„ ì„ ì í•œ ë’¤, í›„ì† ë‹¨ê³„ì—ì„œ orders INSERTì— ëŒ€í•œ ì ê¸ˆì„ ìƒí˜¸ êµì°¨ ìˆœì„œë¡œ ì·¨ë“í•˜ë ¤ í•˜ë©´ì„œ ë°ë“œë½(1213)ì´
ë°œìƒí–ˆê³ , MySQLì´ ë°ë“œë½ì„ ê°ì§€í•˜ê³  í•˜ë‚˜ì˜ íŠ¸ëœì­ì…˜ì„ ë¡¤ë°± ì‹œí‚¤ê³  ì˜¤ë¥˜ ë©”ì„¸ì§€ë¥¼ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤.

### Sequence diagram

```mermaid
sequenceDiagram
    participant T1 as Transaction 1<br/>(Product A ì£¼ë¬¸)
    participant DB as MySQL InnoDB
    participant T2 as Transaction 2<br/>(Product B ì£¼ë¬¸)
    Note over T1, T2: ë™ì¼ ì‚¬ìš©ì, ë‹¤ë¥¸ ìƒí’ˆ ë™ì‹œ ì£¼ë¬¸ ì‹œì‘

    rect rgb(240, 248, 255)
        Note over T1, T2: 1ë‹¨ê³„: ì¤‘ë³µ ì£¼ë¬¸ ê²€ì‚¬ (SELECT FOR UPDATE)
        T1 ->> DB: SELECT * FROM orders<br/>WHERE idempotency_key='order-A'<br/>FOR UPDATE
        Note right of DB: ë ˆì½”ë“œ ì—†ìŒ<br/>â†’ Gap Lock íšë“<br/>(unique index ì „ì²´)
        DB -->> T1: Empty Result + Gap Lock
        T2 ->> DB: SELECT * FROM orders<br/>WHERE idempotency_key='order-B'<br/>FOR UPDATE
        Note right of DB: ë ˆì½”ë“œ ì—†ìŒ<br/>â†’ Gap Lock íšë“<br/>(unique index ì „ì²´)
        DB -->> T2: Empty Result + Gap Lock
    end

    rect rgb(255, 250, 240)
        Note over T1, T2: 2ë‹¨ê³„: ì£¼ë¬¸ ìƒì„± (INSERT)
        T1 ->> DB: INSERT INTO orders<br/>(idempotency_key='order-A', ...)
        Note right of DB: T2ì˜ Gap Lock ëŒ€ê¸° â³
        T2 ->> DB: INSERT INTO orders<br/>(idempotency_key='order-B', ...)
        Note right of DB: T1ì˜ Gap Lock ëŒ€ê¸° â³
    end

    rect rgb(255, 240, 240)
        Note over T1, T2: ğŸ’¥ ë°ë“œë½ ë°œìƒ!
        DB ->> DB: Deadlock Detection
        DB -->> T2: âŒ Deadlock Exception<br/>(Transaction Rollback)
        DB -->> T1: âœ… INSERT Success
    end

    Note over T1, T2: MySQLì´ T2ë¥¼ ë¡¤ë°±í•˜ê³  T1ë§Œ ì„±ê³µ
```

### Business code

```java

@Slf4j
@RequiredArgsConstructor
public class OrderPlaceProcessor {
	private final OrderRepository orderRepository;
	private final PaymentRepository paymentRepository;
	private final ProductRepository productRepository;
	private final UserCouponRepository userCouponRepository;
	private final CashRepository cashRepository;
	private final CashHistoryRepository cashHistoryRepository;
	private final MessageRepository messageRepository;

	@Transactional
	public Output execute(Command command) {
		command.validate();

		/**
		 * ì¤‘ë³µ í˜¸ì¶œì¸ ê²½ìš° ë°˜í™˜í•©ë‹ˆë‹¤.
		 */
		Optional<Order> alreadyPlacedOrderOpt = orderRepository.findByIdempotencyKeyForUpdate(command.idempotencyKey);
		if (alreadyPlacedOrderOpt.isPresent()) {
			return Output.empty();
		}

		// ìƒí’ˆì˜ ë¹„ê´€ì  ì ê¸ˆì„ íšë“í•œ ìƒíƒœë¡œ ì¡°íšŒ ë° ì¬ê³ ë¥¼ ê°ì†Œì‹œí‚µë‹ˆë‹¤.
		List<Product> productsWithDecreasedStock = decreaseStock(command, fetchProductsForUpdate(command));

		Cash cash = cashRepository.findByUserId(command.userId)
			.orElseThrow(() -> new CommerceException(CommerceCode.NOT_FOUND_CASH));

		// ì£¼ë¬¸ ë° ì”ì•¡ì„ ì°¨ê°í•©ë‹ˆë‹¤.
		// ì£¼ë¬¸ ì‹ë³„ìë¥¼ ë¯¸ë¦¬ ë°›ê¸° ìœ„í•´ì„œ save methodë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
		Order order = orderRepository.save(Order.ofPending(command.userId))
			.place(toOrderPlaceInput(command, productsWithDecreasedStock, command.idempotencyKey));

		messageRepository.save(Message.ofPending(
			order.id(),
			MessageTargetType.ORDER,
			OrderConfirmedMessagePayload.from(order.id())
		));

		return isNull(command.userCouponId) ?
			executeWithoutCoupon(command, order, cash, productsWithDecreasedStock) :
			executeWithCoupon(command, order, cash, productsWithDecreasedStock);
	}

	private List<Product> fetchProductsForUpdate(Command command) {
		List<Long> productIds = command.toProductIds();
		List<Product> products = productRepository.findAllByIdInForUpdate(productIds);
		if (products.size() != productIds.size()) {
			throw new CommerceException(CommerceCode.NOT_FOUND_PRODUCT);
		}
		return products;
	}

	private List<Product> decreaseStock(Command command, List<Product> products) {
		Map<Long, Product> productIdToProductMap = products
			.stream()
			.collect(toMap(Product::id, product -> product));

		// ì¬ê³ ë¥¼ ì°¨ê°í•©ë‹ˆë‹¤.
		return command.orderLineCommands()
			.stream()
			.map(orderLineCommand -> {
				Product product = productIdToProductMap.get(orderLineCommand.productId());
				return product.decreaseStock(orderLineCommand.orderQuantity());
			})
			.toList();
	}

	private Output executeWithoutCoupon(Command command, Order order, Cash cash, List<Product> products) {
		validatePaymentAmountIsMatched(command.paymentAmount, order);

		BigDecimal originalBalance = cash.balance();
		Cash usedCash = cash.use(command.paymentAmount);

		Payment payment = Payment.fromOrder(command.userId, order.id(), command.paymentAmount)
			.succeed(command.now);

		cashHistoryRepository.save(
			CashHistory.recordOfPurchase(command.userId, usedCash.balance(), originalBalance));

		return new Output(
			cashRepository.save(usedCash),
			null,
			productRepository.saveAll(products),
			paymentRepository.save(payment),
			orderRepository.save(order)
		);
	}

	private Output executeWithCoupon(Command command, Order order, Cash cash, List<Product> products) {
		UserCoupon userCoupon = userCouponRepository.findById(command.userCouponId)
			.orElseThrow(() -> new CommerceException(CommerceCode.NOT_FOUND_USER_COUPON));

		validatePaymentAmountIsMatched(command.paymentAmount, userCoupon, order);
		userCoupon.use(command.userId, command.now, order.id());

		BigDecimal originalBalance = cash.balance();
		Cash usedCash = cash.use(command.paymentAmount);

		Payment payment = Payment.fromOrder(command.userId, order.id(),
				command.paymentAmount)
			.succeed(command.now);

		cashHistoryRepository.save(
			CashHistory.recordOfPurchase(command.userId, usedCash.balance(), originalBalance));

		return new Output(
			cashRepository.save(cash),
			userCouponRepository.save(userCoupon),
			productRepository.saveAll(products),
			paymentRepository.save(payment),
			orderRepository.save(order)
		);
	}

	private void validatePaymentAmountIsMatched(BigDecimal paymentAmount, UserCoupon userCoupon,
		Order order) {
		BigDecimal actualPaymentAmount = userCoupon.calculateFinalAmount(order.amount());
		if (paymentAmount.compareTo(actualPaymentAmount) != 0) {
			throw new CommerceException(CommerceCode.MISMATCHED_EXPECTED_AMOUNT);
		}
	}

	private void validatePaymentAmountIsMatched(BigDecimal paymentAmount, Order order) {
		BigDecimal actualPaymentAmount = order.amount();
		if (paymentAmount.compareTo(actualPaymentAmount) != 0) {
			throw new CommerceException(CommerceCode.MISMATCHED_EXPECTED_AMOUNT);
		}
	}

	private OrderPlaceInput toOrderPlaceInput(Command command, List<Product> products, String idempotencyKey) {
		Map<Long, Product> productIdToProductMap = products
			.stream()
			.collect(toMap(Product::id, product -> product));

		return OrderPlaceInput.builder()
			.idempotencyKey(idempotencyKey)
			.userId(command.userId())
			.orderLineInputs(command.orderLineCommands()
				.stream()
				.map(orderLineCommand -> {
					Product product = productIdToProductMap.get(orderLineCommand.productId());
					return OrderPlaceInput.OrderLineInput
						.builder()
						.productId(product.id())
						.productName(product.name())
						.productPrice(product.price())
						.orderQuantity(orderLineCommand.orderQuantity())
						.build();
				})
				.toList())
			.build();
	}

	public record Command(
		String idempotencyKey,
		Long userId,
		Long userCouponId,
		BigDecimal paymentAmount,
		LocalDateTime now,
		List<OrderLineCommand> orderLineCommands
	) {
		public void validate() {
			requireNonNull(List.of(Param.of(userId), Param.of(orderLineCommands)));
			if (orderLineCommands.isEmpty()) {
				throw new CommerceException(CommerceCode.ORDER_LINE_COMMANDS_IS_EMPTY);
			}
			orderLineCommands
				.forEach(it -> {
					if (isNull(it.orderQuantity()) || it.orderQuantity() <= 0) {
						throw new CommerceException(CommerceCode.ORDER_QUANTITY_MUST_BE_POSITIVE);
					}
				});
		}

		public List<Long> toProductIds() {
			return orderLineCommands.stream()
				.map(OrderLineCommand::productId)
				.toList();
		}
	}

	public record OrderLineCommand(
		Long productId,
		Integer orderQuantity
	) {
	}

	public record Output(
		Cash cash,
		UserCoupon userCoupon,
		List<Product> products,
		Payment payment,
		Order order
	) {
		public static Output empty() {
			return new Output(
				null,
				null,
				List.of(),
				null,
				null
			);
		}
	}
}

```

## í•´ê²° ë°©ë²•

1. orders (idempotency_key) unique index -> user (id) clustering indexë¡œ ì ê¸ˆ ë³€ê²½ (âœ…)
2. DataIntegrityViolationExceptionì´ ë°œìƒí–ˆì„ ê²½ìš° Rollback ì²˜ë¦¬
3. MySQL Named lockì„ ì´ìš©í•œ ë™ì‹œì„± ì œì–´
4. Optimistic lockì„ ì´ìš©í•œ ë™ì‹œì„± ì œì–´

## ì„ íƒí•œ í•´ê²°ì±… ë° ì´ìœ 

í•´ê²° ë°©ë²• 1ë²ˆì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤. (orders (idempotency_key) unique index -> user (id) clustering indexë¡œ ì ê¸ˆ ë³€ê²½)

- êµ¬í˜„ ë‚œì´ë„ê°€ ê°€ì¥ ê°„ë‹¨í•©ë‹ˆë‹¤.
- ë°ë“œë½ì˜ ë°œìƒ ê°€ëŠ¥ì„±ì„ ì—†ì•±ë‹ˆë‹¤.

### Business code

```java

@Slf4j
@RequiredArgsConstructor
public class OrderPlaceProcessor {
	private final OrderRepository orderRepository;
	private final PaymentRepository paymentRepository;
	private final ProductRepository productRepository;
	private final UserCouponRepository userCouponRepository;
	private final CashRepository cashRepository;
	private final CashHistoryRepository cashHistoryRepository;
	private final MessageRepository messageRepository;
	private final UserRepository userRepository;

	@Transactional
	public Output execute(Command command) {
		command.validate();

		// userì˜ idê°’ìœ¼ë¡œ ì ê¸ˆì„ íšë“í•©ë‹ˆë‹¤.
		userRepository.findByIdForUpdate(command.userId)
			.orElseThrow(() -> new CommerceException(CommerceCode.NOT_FOUND_USER));

		Optional<Order> alreadyPlacedOrderOpt = orderRepository.findByIdempotencyKey(command.idempotencyKey);
		if (alreadyPlacedOrderOpt.isPresent()) {
			return Output.empty();
		}
		// ...
	}
}
```


